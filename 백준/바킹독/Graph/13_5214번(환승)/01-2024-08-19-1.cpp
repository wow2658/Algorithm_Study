#include <iostream>
#include <queue>

using namespace std;

vector<int> adj[101005]; // 인접 리스트, 역과 하이퍼튜브 간의 연결을 저장
int dist[101005]; // 최단 거리 배열, 각 정점까지의 거리를 저장

int main(void)
{
    ios::sync_with_stdio(0); // C++의 입출력 속도를 향상시킴
    cin.tie(0); // 입출력 성능 최적화를 위해 cin과 cout의 묶음을 해제

    int n, k, m; // n: 역의 수, k: 하이퍼튜브가 연결하는 역의 수, m: 하이퍼튜브의 수
    cin >> n >> k >> m; // n, k, m을 입력받음

    // 각 하이퍼튜브에 연결된 역들을 인접 리스트에 추가
    for (int i = 1; i <= m; i++) // 각 하이퍼튜브를 처리
    {
        for (int j = 1; j <= k; j++) // 하이퍼튜브에 연결된 역들을 순차적으로 처리
        {
            int x; // 역 번호를 저장할 변수
            cin >> x; // 역 번호를 입력받음

            adj[n + i].push_back(x); // 하이퍼튜브를 역과 연결, n+i는 하이퍼튜브의 번호를 의미
            adj[x].push_back(n + i); // 역에서 하이퍼튜브로의 연결 추가
        }
    }

    fill(dist, dist + n + m + 1, -1); // dist 배열을 -1로 초기화, 아직 방문하지 않았음을 의미

    queue<int> q; // BFS를 위한 큐 선언
    q.push(1); // 출발점인 1번 역을 큐에 넣음
    dist[1] = 0; // 1번 역의 거리를 0으로 설정

    // BFS 알고리즘을 이용하여 최단 거리를 계산
    while (!q.empty()) // 큐가 비어있지 않은 동안 반복
    {
        int cur = q.front(); // 큐의 맨 앞 요소를 가져옴
        q.pop(); // 큐에서 제거

        // 현재 역(cur)과 연결된 역들을 탐색
        for (int nxt : adj[cur])
        {
            if (dist[nxt] != -1) // 이미 방문한 역이라면 건너뜀
            {
                continue;
            }

            q.push(nxt); // 다음 역을 큐에 추가
            dist[nxt] = dist[cur] + 1; // 다음 역의 거리를 현재 역에서 1 증가시킴
        }
    }

    // N번 역까지의 최단 거리가 -1이면 도달할 수 없음을 의미
    if (dist[n] == -1)
    {
        cout << dist[n]; // -1 출력
    }
    else // N번 역에 도달할 수 있다면
    {
        cout << dist[n] / 2 + 1; // 하이퍼튜브로 인한 간선 연결 고려, 최단 경로 출력
    }
}

/*
코드 설명:
- 이 문제에서 한 하이퍼튜브에 연결된 모든 역들을 서로 직접 연결하지 않고, 하이퍼튜브 자체를 하나의 정점으로 생각하여 그래프를 구성합니다.
- BFS를 사용하여 1번 역에서 N번 역까지의 최단 경로를 탐색합니다.
- 하이퍼튜브를 통해 이동한 경우를 고려하여 결과를 출력할 때 거리를 2로 나누고 1을 더합니다.
*/

