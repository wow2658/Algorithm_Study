#include <iostream>
#include <queue>
#include <tuple>
using namespace std;
#define X first
#define Y second

int dx[4] = { 0,1,0,-1 };
int dy[4] = { 1,0,-1,0 };

char board[1000][1000];   // 입력받은 맵을 저장할 2차원 배열
int dist[1000][1000][2];  // 거리를 저장할 3차원 배열
// dist[x][y][0] : 벽을 하나도 부수지 않고 (x,y)까지 오는데 걸리는 비용
// dist[x][y][1] : 벽을 하나만 부수고 (x,y)까지 오는데 걸리는 비용, (x,y)가 벽이라서 부수는 경우 포함

int n, m;  // 맵의 크기

// BFS 함수
int bfs()
{
    // 거리 배열 초기화
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            dist[i][j][0] = dist[i][j][1] = -1;

    // 시작점 초기화
    dist[0][0][0] = dist[0][0][1] = 1;
    queue<tuple<int, int, int>> q;
    q.push({ 0,0,0 });  // 시작점 큐에 삽입 (x, y, 벽을 부쉈는지 여부)

    while (!q.empty())
    {
        int x, y, broken;
        tie(x, y, broken) = q.front();  // 현재 위치와 상태

        if (x == n - 1 && y == m - 1) 
            return dist[x][y][broken];  // 목적지 도달 시 거리 반환

        q.pop();

        int nextdist = dist[x][y][broken] + 1;  // 다음 위치의 거리

        // 4방향 탐색
        for (int dir = 0; dir < 4; ++dir)
        {
            int nx = x + dx[dir];
            int ny = y + dy[dir];
            if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;  // 맵 범위 벗어나면 skip

            // 벽이 아니고 아직 방문하지 않은 경우
            if (board[nx][ny] == '0' && dist[nx][ny][broken] == -1)
            {
                dist[nx][ny][broken] = nextdist;
                q.push({ nx, ny, broken });
            }

            // 벽을 아직 부수지 않았고, 다음 위치가 벽이며, 벽을 부순 상태로 방문하지 않은 경우
            if (!broken && board[nx][ny] == '1' && dist[nx][ny][1] == -1)
            {
                dist[nx][ny][1] = nextdist;
                q.push({ nx, ny, 1 });
            }
        }
    }
    return -1;  // 목적지에 도달할 수 없는 경우
}

int main(void)
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n >> m;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            cin >> board[i][j];

    cout << bfs();
    return 0;
}


/*
    0 1 0
    0 1 0
    0 0 1


    시작: (0,0), broken = 0
    
    dist[0][0][0] = 1
    큐에 (0,0,0) 추가
    
    

    (0,0,0) 처리:
    
    아래로 이동 가능: (1,0)
    첫 번째 if문 실행: dist[1][0][0] = 2, 큐에 (1,0,0) 추가
    
    오른쪽으로 이동 불가능 (벽)
    두 번째 if문 실행: dist[0][1][1] = 2, 큐에 (0,1,1) 추가
    
    
    
    (1,0,0) 처리:
    
    아래로 이동 가능: (2,0)
    첫 번째 if문 실행: dist[2][0][0] = 3, 큐에 (2,0,0) 추가
    
    오른쪽으로 이동 불가능 (벽)
    두 번째 if문 실행: dist[1][1][1] = 3, 큐에 (1,1,1) 추가
    
    
    
    (0,1,1) 처리 (벽을 부순 상태):
    아래로 이동 가능: (1,1)
    첫 번째 if문 실행: dist[1][1][1] = 3 (이미 설정되어 있으므로 무시)
    
    
    오른쪽으로 이동 가능: (0,2)
    첫 번째 if문 실행: dist[0][2][1] = 3, 큐에 (0,2,1) 추가
    
    
    계속해서 BFS 진행
    최종적으로 (2,2)에 도달할 때:
    
    dist[2][2][1]이 설정됨 (벽을 한 번 부수고 도달)
*/


/*

이 문제는 일반적인 BFS 문제와 비교하여 아래과 같은 주요 차이점이 있다.

1. 상태의 추가 차원:

일반 BFS에서는 보통 2차원 배열(x, y)로 방문 여부를 체크한다.
이 문제에서는 3차원 배열(x, y, broken)을 사용하여 벽을 부쉈는지 여부까지 고려한다.



2. 조건부 이동:



일반 BFS에서는 대개 이동 가능/불가능의 두 가지 상태만 존재한다.
이 문제에서는 벽을 한 번 부술 수 있는 옵션이 추가되어, 이동 불가능한 곳도 조건부로 이동할 수 있다.



3. 다중 상태 탐색:

일반 BFS에서는 각 위치에 대해 한 번만 방문한다.
이 문제에서는 각 위치를 두 가지 상태(벽을 부순 상태와 부수지 않은 상태)로 별도로 방문할 수 있다.



4. 복잡한 방문 체크:

일반 BFS에서는 단순히 방문 여부만 체크한다.
이 문제에서는 현재 상태(벽을 부쉈는지 여부)에 따라 다른 방문 체크 로직을 사용한다.



5. 조건부 목표 도달:

일반 BFS에서는 목표 지점에 도달하면 종료한다.
이 문제에서는 목표 지점에 도달하더라도, 벽을 부순 상태와 부수지 않은 상태 중 더 빠른 경로를 선택해야 한다.



6. 이동 규칙의 변화:

일반 BFS에서는 이동 규칙이 일정하다.
이 문제에서는 벽을 부수지 않은 상태에서는 추가적인 이동 옵션(벽 부수기)이 존재한다.



이러한 차이점들로 인해 이 문제는 일반적인 BFS보다 더 복잡한 로직과 추가적인 상태 관리를 요구한다. 
이는 문제의 난이도를 높이고, 보다 세밀한 구현을 필요로 한다.


*/