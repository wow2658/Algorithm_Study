#include <iostream>

using namespace std;

int N, M, x, y, K, command;
int board[21][21];  // 지도를 나타내는 2차원 배열이다.
int dice[7];        // 주사위의 각 면을 나타내는 1차원 배열이다.

// 주사위 면의 인덱스를 나타내는 2차원 배열이다.
int idx[5][4] =
{
    {},        // 더미 데이터이다.
    {2,6,4,5}, // 동쪽으로 굴릴 때의 면 변화 순서이다. 5->2, 2->6, 6->4, 4->5
    {2,5,4,6}, // 서쪽으로 굴릴 때의 면 변화 순서이다. 6->2, 2->5, 5->4, 4->6
    {3,2,1,4}, // 북쪽으로 굴릴 때의 면 변화 순서이다. 4->3, 3->2, 2->1, 1->4
    {2,3,4,1}, // 남쪽으로 굴릴 때의 면 변화 순서이다. 1->2, 2->3, 3->4, 4->1
};

// 주사위 이동이 유효한지 검증하는 함수이다.
bool isOk(int nx, int ny)
{
    if (nx < 0 || nx >= N || ny < 0 || ny >= M)
        return false;
    return true;
}

// 주사위를 굴리는 함수이다.
void roll(int com)
{
    // 회전 시 기존 주사위의 값을 별도로 보존하기 위한 배열을 생성한다.
    int tmp[7];
    for (int i = 1; i <= 6; ++i)
        tmp[i] = dice[i];

    // 굴리는 것을 처리한다.
    for (int i = 0; i < 4; i++)
        tmp[idx[com][i]] = dice[idx[com][(i + 1) % 4]];

    // 회전 결과값을 기존 주사위에 대입한다.
    for (int i = 1; i <= 6; ++i)
        dice[i] = tmp[i];
}

// 주사위를 굴리고 점수를 계산하는 함수이다.
void score(int c)
{
    int nx = x, ny = y;

    // 주사위 위치를 이동한다.
    if (c == 1)
        ++ny;
    else if (c == 2)
        --ny;
    else if (c == 3)
        --nx;
    else
        ++nx;

    if (isOk(nx, ny))
    {
        x = nx;
        y = ny; // 유효성 확인 후 주사위의 위치를 대입한다.
        roll(c);

        // 이동한 칸이 0일 경우를 처리한다.
        if (board[nx][ny] == 0)
            board[nx][ny] = dice[4]; // 칸에 바닥면 값을 대입한다.

        // 이동한 칸이 0이 아닐 경우를 처리한다.
        else
        {
            dice[4] = board[nx][ny]; // 바닥면에 칸 값을 대입한다.
            board[nx][ny] = 0; // 칸 값을 0으로 초기화한다.
        }
        cout << dice[2] << '\n'; // 주사위 윗면을 출력한다.
    }
}

int main(void)
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    // 입력을 받는다.
    cin >> N >> M >> x >> y >> K;
    for (int i = 0; i < N; ++i)
        for (int j = 0; j < M; ++j)
            cin >> board[i][j];

    // 명령을 처리한다.
    while (K--)
    {
        cin >> command;
        score(command);
    }

    return 0;
}

/*

주사위의 구조는 다음과 같다:
    [1]
 [5][2][6]
    [3]
    [4]

여기서 2가 윗면이고, 4가 바닥면이다.
코드를 분석하면 다음과 같다:

for(int i = 0; i < 4; i++)
    tmp[idx[com][i]] = dice[idx[com][(i+1)%4]];

idx 배열은 각 방향으로 굴릴 때 변화하는 면의 순서를 나타낸다.
예를 들어, 동쪽으로 굴릴 때(com이 1일 때) idx[1]은 {2,6,4,5}이다.
이 코드는 4번 반복한다. 주사위를 굴릴 때 4개의 면이 변하기 때문이다.

각 반복에서 다음을 수행한다:

tmp[idx[com][i]]는 새로운 위치에 올 면을 나타낸다.
dice[idx[com][(i+1)%4]]는 그 위치로 이동할 면의 현재 값이다.

동쪽으로 굴리는 경우를 예로 들면 다음과 같다:

i=0일 때: tmp[2] = dice[6]  (윗면이 오른쪽 면의 값으로 변한다)
i=1일 때: tmp[6] = dice[4]  (오른쪽 면이 바닥 면의 값으로 변한다)
i=2일 때: tmp[4] = dice[5]  (바닥 면이 왼쪽 면의 값으로 변한다)
i=3일 때: tmp[5] = dice[2]  (왼쪽 면이 원래 윗면의 값으로 변한다)

이렇게 해서 주사위가 한 번 굴러가는 효과를 만들어낸다. 각 면의 값들이 굴러가는 방향으로 한 칸씩 이동하는 것이다.

*/