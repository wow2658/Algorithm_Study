#include <iostream>
using namespace std;

typedef long long ll; // N이 90만 가도 엄청나게 커서 오버플로우가 난다. 풀기전에 이걸 어떻게 예측할까?

int n;
ll d[100][2]; // d[n][0]: n자리 이친수 중 마지막 자리가 0인 경우의 수   
              // d[n][1]: n자리 이친수 중 마지막 자리가 1인 경우의 수

int main(void) 
{
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> n;
    d[1][1] = 1LL; // d[1][0] = 0; 1자리 이친수 중 마지막 자리가 0인 경우는 없음
    for (int i = 2; i <= n; ++i) 
    {
        d[i][0] = d[i - 1][0] + d[i - 1][1];
        d[i][1] = d[i - 1][0]; //전에 1이었을 경우는 어차피 무시하니 전의 0수를 그대로 가져가는 느낌
    }
    cout << d[n][0] + d[n][1];
}

/*
1LL의 의미는?
 1LL은 숫자 1을 long long 자료형으로 명시적으로 나타낸 것이다. LL은 long long 타입 리터럴을 의미한다.
위에서 정의한 typedef long long ll와는 관계가 없고
컴파일러가 이 접미사를 인식하여 정수 리터럴을 적절한 타입으로 처리한다

왜 굳이 1LL로 쓰는가?
 타입 안정성 보장
1LL로 명시하면 해당 리터럴이 long long 타입으로 지정되어, 
이후 연산에서도 long long 타입으로 처리된다. 이는 프로그램이 커지고 복잡해질수록 중요한데, 
명시적으로 타입을 지정함으로써 타입 안정성을 보장할 수 있다.

 오버플로우 방지
만약 큰 숫자를 다루는 상황에서 int 타입을 사용하면, 해당 타입의 최대 값을 초과할 때 오버플로우가 발생할 수 있다. 
long long 타입을 사용하면 64비트 범위 내에서 훨씬 더 큰 값을 안전하게 다룰 수 있다. 
1LL을 사용함으로써 숫자 리터럴이 long long 타입임을 명확히 하여 오버플로우의 위험을 줄일 수 있다.

 명시적 의도 표현
코드를 읽는 다른 개발자들이나 미래의 자신에게 해당 리터럴이 long long 타입임을 명확히 알리는 역할을 한다. 
이는 코드의 가독성을 높이고 유지보수성을 향상시킬 수 있다. 
명시적 타입 지정은 특히 팀 단위 개발이나 오픈 소스 프로젝트에서 코드의 일관성을 유지하는 데 도움이 된다.
*/