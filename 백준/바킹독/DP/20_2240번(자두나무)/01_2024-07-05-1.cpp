#include <iostream>
using namespace std;

int a[1002];
int d[1002][32][3]; // d[i][j][k]: i:현재시간, j:이동횟수, k:나무번호

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	int t, w;
	cin >> t >> w;
	for (int i = 1; i <= t; i++)
		cin >> a[i]; // 자두가 떨어지는 나무의 정보를 저장

	for (int i = 1; i <= t; i++)
	{
		// 자두가 처음에 1번 나무 아래에 위치하니까
		d[i][0][1] = d[i - 1][0][1] + (a[i] == 1 ? 1 : 0); // 1번 나무에서 떨어지는 자두면 받고 시작한다.

		for (int j = 1; j <= w; j++) // j: 이동 횟수
		{
			if (i < j) break; // 현재 시간보다 많이 이동할 수 없다

			if (a[i] == 1)  // 현재 1번 나무에서 자두가 떨어질 때
			{
				// d[i][j][1]: 현재 1번 나무 아래에 있는 경우 + 1
				// max(d[i - 1][j - 1][2], d[i - 1][j][1]) + 1:
				// 이전 시간(i-1)에 2번 나무에 있었고(j-1번 이동한 상태), 이번 시간(i)에 1번 나무로 이동한 경우
				// vs
				// 이전 시간(i-1)에 1번 나무 아래에 계속 있었던 경우(j번 이동한 상태)
				// 위 두 경우 중 큰 값에 현재 1번 나무에서 떨어진 자두(1개)를 더한 값
				d[i][j][1] = max(d[i - 1][j - 1][2], d[i - 1][j][1]) + 1;

				// d[i][j][2]: 현재 2번 나무 아래에 있는 경우
				// max(d[i - 1][j - 1][1], d[i - 1][j][2]):
				// 이전 시간(i-1)에 1번 나무에 있었고(j-1번 이동한 상태), 이번 시간(i)에 2번 나무로 이동한 경우
				// vs
				// 이전 시간(i-1)에 2번 나무 아래에 계속 있었던 경우(j번 이동한 상태)
				// 위 두 경우 중 큰 값
				d[i][j][2] = max(d[i - 1][j - 1][1], d[i - 1][j][2]);
			}

			else // 현재 2번 나무에서 자두가 떨어질 때
			{
				// d[i][j][1]: 현재 1번 나무 아래에 있는 경우
				// max(d[i - 1][j - 1][2], d[i - 1][j][1]):
				// 이전 시간(i-1)에 2번 나무에 있었고(j-1번 이동한 상태), 이번 시간(i)에 1번 나무로 이동한 경우
				// vs
				// 이전 시간(i-1)에 1번 나무 아래에 계속 있었던 경우(j번 이동한 상태)
				// 위 두 경우 중 큰 값
				d[i][j][1] = max(d[i - 1][j - 1][2], d[i - 1][j][1]);

				// d[i][j][2]: 현재 2번 나무 아래에 있는 경우 + 1
				// max(d[i - 1][j - 1][1], d[i - 1][j][2]) + 1:
				// 이전 시간(i-1)에 1번 나무에 있었고(j-1번 이동한 상태), 이번 시간(i)에 2번 나무로 이동한 경우
				// vs
				// 이전 시간(i-1)에 2번 나무 아래에 계속 있었던 경우(j번 이동한 상태)
				// 위 두 경우 중 큰 값에 현재 2번 나무에서 떨어진 자두(1개)를 더한 값
				d[i][j][2] = max(d[i - 1][j - 1][1], d[i - 1][j][2]) + 1;
			}
		}
	}
	int ans = 0;
	for (int j = 0; j <= w; j++)
		ans = max({ ans, d[t][j][1], d[t][j][2] });  // 모든 시간 t까지, 모든 이동 횟수 w에 대해 최대 자두 개수 찾기
	cout << ans;
}
