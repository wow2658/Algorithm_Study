#include <iostream>
using namespace std;

int t[20];
int p[20];
int d[20]; // i번째 일에 상담을 시작했을 때 얻을 수 있는 최대 수익

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	int n;
	cin >> n;

	for (int i = 1; i <= n; i++) cin >> t[i] >> p[i];

	for (int i = n; i >= 1; i--)
	{
		// i번째 일에 상담을 할 수 있을 경우
		// (현재 상담을 시작하는 날 + 현재 상담이 걸리는 기간) <= 퇴사일
		if (i + t[i] <= n + 1)
		{
			// i번째 일에 상담을 했을 때와 상담을 하지 않았을 때 얻을 수 있는 수익 중 최대 수익을 취함
			// 
			// 상담을 하는 경우는 i번째 날 상담의 수익과 해당 상담이 끝난 후 얻을 수 있는 최대 수익의 합이 i번째 날의 최대 수익이다.
			// 상담을 하지 않는 경우는 i번째 날의 최대 수익은 다음 날의 최대 수익과 동일
			// 
			// 역순으로 내려온다는것을 생각해야한다. d[i+1]이 d[i]보다 먼저 채워져있다.
			d[i] = max(d[i + t[i]] + p[i], d[i + 1]);
		}
		// 상담을 할 수 없다면 다음 날의 최대 수익 가져오기
		else d[i] = d[i + 1];
	}

	cout << *max_element(d, d + n + 1);
}

/*
역순으로 계산

ex)
7일 (i = 7):

상담 기간이 2일, 수익이 200
7 + 2 = 9 > 8 (즉, 상담 불가능)
d[7] = d[8] (d[8]은 0으로 초기화 되어 있음)
d[7] = 0
6일 (i = 6):

상담 기간이 4일, 수익이 40
6 + 4 = 10 > 8 (즉, 상담 불가능)
d[6] = d[7]
d[6] = 0
5일 (i = 5):

상담 기간이 2일, 수익이 15
5 + 2 = 7 ≤ 8 (즉, 상담 가능)
상담하지 않는 경우: d[5] = d[6] = 0
상담하는 경우: d[5] = d[7] + 15 = 0 + 15 = 15
d[5] = max(15, 0) = 15
4일 (i = 4):

상담 기간이 1일, 수익이 20
4 + 1 = 5 ≤ 8 (즉, 상담 가능)
상담하지 않는 경우: d[4] = d[5] = 15
상담하는 경우: d[4] = d[5] + 20 = 15 + 20 = 35
d[4] = max(35, 15) = 35
3일 (i = 3):

상담 기간이 1일, 수익이 10
3 + 1 = 4 ≤ 8 (즉, 상담 가능)
상담하지 않는 경우: d[3] = d[4] = 35
상담하는 경우: d[3] = d[4] + 10 = 35 + 10 = 45
d[3] = max(45, 35) = 45
2일 (i = 2):

상담 기간이 5일, 수익이 20
2 + 5 = 7 ≤ 8 (즉, 상담 가능)
상담하지 않는 경우: d[2] = d[3] = 45
상담하는 경우: d[2] = d[7] + 20 = 0 + 20 = 20
d[2] = max(20, 45) = 45
1일 (i = 1):

상담 기간이 3일, 수익이 10
1 + 3 = 4 ≤ 8 (즉, 상담 가능)
상담하지 않는 경우: d[1] = d[2] = 45
상담하는 경우: d[1] = d[4] + 10 = 35 + 10 = 45
d[1] = max(45, 45) = 45

*/